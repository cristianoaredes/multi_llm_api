// This is a placeholder file to demonstrate the structure of the generated API code.
// The actual code would be generated by the swagger_dart_code_generator package.

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'models.dart';

/// API Client for interacting with the API Dart Example API.
class ApiClient {
  /// Base URL for the API.
  final String baseUrl;
  
  /// HTTP client for making requests.
  final http.Client _httpClient;
  
  /// Authentication token for Bearer authentication.
  String? _bearerToken;
  
  /// Creates a new API client with the given base URL.
  ApiClient({
    required this.baseUrl,
    http.Client? httpClient,
  }) : _httpClient = httpClient ?? http.Client();
  
  /// Sets the Bearer authentication token.
  void setBearerAuth(String token) {
    _bearerToken = token;
  }
  
  /// Clears the authentication token.
  void clearAuth() {
    _bearerToken = null;
  }
  
  /// Creates headers for a request, including authentication if set.
  Map<String, String> _createHeaders({
    Map<String, String>? additionalHeaders,
    bool requiresAuth = true,
  }) {
    final headers = <String, String>{
      'Content-Type': 'application/json',
      ...?additionalHeaders,
    };
    
    if (requiresAuth && _bearerToken != null) {
      headers['Authorization'] = 'Bearer $_bearerToken';
    }
    
    return headers;
  }
  
  /// Performs a GET request to the given path.
  Future<T> _get<T>(
    String path, {
    Map<String, String>? queryParams,
    Map<String, String>? headers,
    bool requiresAuth = true,
    required T Function(Map<String, dynamic> json) fromJson,
  }) async {
    final uri = Uri.parse('$baseUrl$path').replace(
      queryParameters: queryParams,
    );
    
    final response = await _httpClient.get(
      uri,
      headers: _createHeaders(
        additionalHeaders: headers,
        requiresAuth: requiresAuth,
      ),
    );
    
    if (response.statusCode >= 200 && response.statusCode < 300) {
      final json = jsonDecode(response.body) as Map<String, dynamic>;
      return fromJson(json);
    } else {
      throw _handleError(response);
    }
  }
  
  /// Performs a POST request to the given path.
  Future<T> _post<T>(
    String path, {
    Object? body,
    Map<String, String>? queryParams,
    Map<String, String>? headers,
    bool requiresAuth = true,
    required T Function(Map<String, dynamic> json) fromJson,
  }) async {
    final uri = Uri.parse('$baseUrl$path').replace(
      queryParameters: queryParams,
    );
    
    final response = await _httpClient.post(
      uri,
      headers: _createHeaders(
        additionalHeaders: headers,
        requiresAuth: requiresAuth,
      ),
      body: body != null ? jsonEncode(body) : null,
    );
    
    if (response.statusCode >= 200 && response.statusCode < 300) {
      final json = jsonDecode(response.body) as Map<String, dynamic>;
      return fromJson(json);
    } else {
      throw _handleError(response);
    }
  }
  
  /// Performs a PUT request to the given path.
  Future<T> _put<T>(
    String path, {
    Object? body,
    Map<String, String>? queryParams,
    Map<String, String>? headers,
    bool requiresAuth = true,
    required T Function(Map<String, dynamic> json) fromJson,
  }) async {
    final uri = Uri.parse('$baseUrl$path').replace(
      queryParameters: queryParams,
    );
    
    final response = await _httpClient.put(
      uri,
      headers: _createHeaders(
        additionalHeaders: headers,
        requiresAuth: requiresAuth,
      ),
      body: body != null ? jsonEncode(body) : null,
    );
    
    if (response.statusCode >= 200 && response.statusCode < 300) {
      final json = jsonDecode(response.body) as Map<String, dynamic>;
      return fromJson(json);
    } else {
      throw _handleError(response);
    }
  }
  
  /// Performs a DELETE request to the given path.
  Future<void> _delete(
    String path, {
    Map<String, String>? queryParams,
    Map<String, String>? headers,
    bool requiresAuth = true,
  }) async {
    final uri = Uri.parse('$baseUrl$path').replace(
      queryParameters: queryParams,
    );
    
    final response = await _httpClient.delete(
      uri,
      headers: _createHeaders(
        additionalHeaders: headers,
        requiresAuth: requiresAuth,
      ),
    );
    
    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw _handleError(response);
    }
  }
  
  /// Handles errors from the API.
  Exception _handleError(http.Response response) {
    try {
      final json = jsonDecode(response.body) as Map<String, dynamic>;
      final error = ApiError.fromJson(json);
      
      switch (response.statusCode) {
        case 400:
          return BadRequestException(error.message);
        case 401:
          return UnauthorizedException(error.message);
        case 403:
          return ForbiddenException(error.message);
        case 404:
          return NotFoundException(error.message);
        default:
          return ApiException(
            error.message,
            statusCode: response.statusCode,
          );
      }
    } catch (e) {
      return ApiException(
        'An error occurred: ${response.body}',
        statusCode: response.statusCode,
      );
    }
  }
  
  // API Endpoints
  
  /// Health check endpoint.
  Future<String> healthGet() async {
    final response = await _httpClient.get(
      Uri.parse('$baseUrl/health'),
    );
    
    if (response.statusCode >= 200 && response.statusCode < 300) {
      return response.body;
    } else {
      throw _handleError(response);
    }
  }
  
  /// User login endpoint.
  Future<LoginResponse> authLogin({
    required LoginRequest loginRequest,
  }) async {
    return _post(
      '/auth/login',
      body: loginRequest.toJson(),
      requiresAuth: false,
      fromJson: LoginResponse.fromJson,
    );
  }
  
  /// User registration endpoint.
  Future<UserResponse> authRegister({
    required RegisterRequest registerRequest,
  }) async {
    return _post(
      '/auth/register',
      body: registerRequest.toJson(),
      requiresAuth: false,
      fromJson: UserResponse.fromJson,
    );
  }
  
  /// Verify token endpoint.
  Future<UserResponse> authVerify() async {
    return _get(
      '/auth/verify',
      fromJson: UserResponse.fromJson,
    );
  }
  
  /// List items endpoint.
  Future<PaginatedItems> itemsGet({
    int? page,
    int? pageSize,
  }) async {
    return _get(
      '/items',
      queryParams: {
        if (page != null) 'page': page.toString(),
        if (pageSize != null) 'pageSize': pageSize.toString(),
      },
      fromJson: PaginatedItems.fromJson,
    );
  }
  
  /// Create item endpoint.
  Future<Item> itemsPost({
    required CreateItemRequest createItemRequest,
  }) async {
    return _post(
      '/items',
      body: createItemRequest.toJson(),
      fromJson: Item.fromJson,
    );
  }
  
  /// Create multiple items endpoint.
  Future<List<Item>> itemsBatchPost({
    required List<CreateItemRequest> createItemRequests,
  }) async {
    return _post(
      '/items/batch',
      body: createItemRequests.map((e) => e.toJson()).toList(),
      fromJson: (json) {
        final list = json['items'] as List;
        return list.map((e) => Item.fromJson(e as Map<String, dynamic>)).toList();
      },
    );
  }
  
  /// Get item by ID endpoint.
  Future<Item> itemsIdGet({
    required int id,
  }) async {
    return _get(
      '/items/$id',
      fromJson: Item.fromJson,
    );
  }
  
  /// Update item endpoint.
  Future<Item> itemsIdPut({
    required int id,
    required UpdateItemRequest updateItemRequest,
  }) async {
    return _put(
      '/items/$id',
      body: updateItemRequest.toJson(),
      fromJson: Item.fromJson,
    );
  }
  
  /// Delete item endpoint.
  Future<void> itemsIdDelete({
    required int id,
  }) async {
    return _delete('/items/$id');
  }
  
  /// Transfer item endpoint.
  Future<Item> itemsIdTransferPost({
    required int id,
    required TransferItemRequest transferItemRequest,
  }) async {
    return _post(
      '/items/$id/transfer',
      body: transferItemRequest.toJson(),
      fromJson: Item.fromJson,
    );
  }
  
  /// Generate text endpoint.
  Future<GenerateTextResponse> generateTextPost({
    required GenerateTextRequest generateTextRequest,
  }) async {
    return _post(
      '/generate/text',
      body: generateTextRequest.toJson(),
      fromJson: GenerateTextResponse.fromJson,
    );
  }
}

/// Base exception for API errors.
class ApiException implements Exception {
  final String message;
  final int statusCode;
  
  ApiException(this.message, {required this.statusCode});
  
  @override
  String toString() => 'ApiException: $message (Status code: $statusCode)';
}

/// Exception for 400 Bad Request errors.
class BadRequestException extends ApiException {
  BadRequestException(String message) : super(message, statusCode: 400);
}

/// Exception for 401 Unauthorized errors.
class UnauthorizedException extends ApiException {
  UnauthorizedException(String message) : super(message, statusCode: 401);
}

/// Exception for 403 Forbidden errors.
class ForbiddenException extends ApiException {
  ForbiddenException(String message) : super(message, statusCode: 403);
}

/// Exception for 404 Not Found errors.
class NotFoundException extends ApiException {
  NotFoundException(String message) : super(message, statusCode: 404);
}
